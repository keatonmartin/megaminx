package main

import (
	"bytes"
	"math"
	"strconv"
)

// Node represents Nodes on A* search
type Node struct {
	prev *Node
	s    *State
	g    int
	h    int
}

// H returns the heuristic value of a given state
func H(s State) int {
	wrong := 0 // count of stickers on the wrong face
	for i := 0; i < 12; i++ {
		for j := 0; j < 10; j++ {
			if s[i][j] != byte(i) {
				wrong++
			}
		}
	}
	return int(math.Ceil(float64(wrong) / 15.0)) // ceil(wrong / 15)
}

// Child returns all children of Node n
// Note: only children generated by rotating the puzzle counter-clockwise are considered
func Child(n Node) []Node {
	var res []Node
	for i := 0; i < 12; i++ {
		s := CopyState(*(n.s))
		s.CCW(i)
		res = append(res, Node{&n, &s, n.g + 1, H(s)})
	}
	return res
}

func (s *State) String() string {
	var buffer bytes.Buffer
	for i := 0; i < 12; i++ {
		for j := 0; j < 10; j++ {
			buffer.WriteString(strconv.Itoa(int(s[i][j])))
		}
	}
	return buffer.String()
}

// Solve is an implementation of A*, returns the final node
func Solve(s State) Node {
	start := Node{nil, &s, 0, H(s)}
	var pq MinHeap
	reached := make(map[string]int)
	pq.Insert(start)

	for pq.Len() > 0 {
		top := pq.Pop()
		if top.h == 0 {
			return top
		}
		for _, child := range Child(top) {
			c := child.s.String()
			if _, ok := reached[c]; !ok || child.g < reached[c] {
				reached[c] = child.g
				pq.Insert(child)
			}
		}
	}
	return Node{}
}

func Test(k int) {
	s := NewState()
	s.randomize(k)

	//startTime := time.Now()
	Solve(s)
	//elapsedTime := time.Since(startTime)
	//
	//// fmt.Printf("Solve for k = %d took %s to run\n", k, elapsedTime)
	//
	//// fmt.Println(result)
}

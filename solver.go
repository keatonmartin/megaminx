package main

import (
	"bytes"
	"fmt"
	"math"
	"strconv"
)

// Node represents Nodes on A* search
type Node struct {
	prev *Node
	s    *State
	g    int
	h    int
}

// H returns the heuristic value of a given state
func H(s State) int {
	wrong := 0 // count of stickers on the wrong face
	for i := 0; i < 12; i++ {
		for j := 0; j < 10; j++ {
			if s[i][j] != byte(i) {
				wrong++
			}
		}
	}
	return int(math.Ceil(float64(wrong) / 15.0)) // ceil(wrong / 15)
}

// Child returns all children of Node n
// Note: only children generated by rotating the puzzle counter-clockwise are considered
func Child(n Node) []Node {
	var res []Node
	for i := 0; i < 12; i++ {
		s := CopyState(*(n.s))
		s.CCW(i)
		res = append(res, Node{&n, &s, n.g + 1, H(s)})
	}
	return res
}

// String returns the string representation of s. Used as a key into the map tracking reached nodes
func (s *State) String() string {
	var buffer bytes.Buffer
	for i := 0; i < 12; i++ {
		for j := 0; j < 10; j++ {
			buffer.WriteString(strconv.Itoa(int(s[i][j])))
		}
	}
	return buffer.String()
}

// Solve is an implementation of A*, returns the size of the frontier when the solved state is reached
func Solve(s State) (int, Node) {
	start := Node{nil, &s, 0, H(s)}
	var pq MinHeap
	reached := make(map[string]int)
	pq.Insert(start)

	for pq.Len() > 0 { // while the frontier is non-empty
		top := pq.Pop() // extract min from frontier
		if top.h == 0 { // if goal state reached, we're done
			return pq.Len(), top
		}
		for _, child := range Child(top) { /// for each child node
			c := child.s.String()                                 // get string encoding for lookup into reached nodes map
			if _, ok := reached[c]; !ok || child.g < reached[c] { // if child hasn't been reached, or shorter path to child found
				reached[c] = child.g // update cost for child node
				pq.Insert(child)     // insert child into frontier
			}
		}
	}
	return -1, Node{} // return -1 if unsolvable, shouldn't happen with any start state generated by Randomize
}

// Test will generate a puzzle with k random clockwise rotations and call Solve on the randomized puzzle state
func Test(k int) (int, Node) {
	s := NewState()
	s.randomize(k)
	return Solve(s)
}

// TestSuite reports the average frontier size for 5 iterations of solving for k = 3 to k = 14
func TestSuite() {
	// for k = 3 to 14, generate 5 k-randomized puzzles and solve
	for k := 3; k < 15; k++ {
		frontierSize := 0
		for i := 0; i < 5; i++ {
			front, node := Test(k)
			frontierSize += front
			if gui {
				go unwind(node)
			}

			fmt.Printf("Solved #%d ", i+1)
		}
		fmt.Printf("\nfor k = %d, average frontier size on solve is %.2f\n", k, float64(frontierSize)/5.0)
	}
}
